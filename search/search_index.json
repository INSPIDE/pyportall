{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pyportall pyportall is Portall's Python SDK, the Python gateway to Portall's data and services. Warning Much like Portall itself, pyportall is still in a very early stage of development. So please bear with us. We will do our best to limit backwards-incompatible changes, but we will certainly have to live with them for a while. Thanks for understanding. You can also expect this documentation to improve a lot in the coming weeks!","title":"Welcome to pyportall"},{"location":"#welcome-to-pyportall","text":"pyportall is Portall's Python SDK, the Python gateway to Portall's data and services.","title":"Welcome to pyportall"},{"location":"#warning","text":"Much like Portall itself, pyportall is still in a very early stage of development. So please bear with us. We will do our best to limit backwards-incompatible changes, but we will certainly have to live with them for a while. Thanks for understanding. You can also expect this documentation to improve a lot in the coming weeks!","title":"Warning"},{"location":"examples/","text":"Examples Simple, generic usage example This is a very simple example that outlines how the different components work and interact with each other. The problem we will be trying to solve is understanding how many people can be counted on a Friday in February from 3pm to 4pm in the surroundings of two given locations. First of all, let us do the imports: import pandas as pd import geopandas as gpd from pyportall.api.engine.core import APIClient from pyportall.api.models.lbs import GeocodingOptions from pyportall.api.engine.geopandas import GeocodingHelper, IsolineHelper, IsovistHelper, IndicatorHelper from pyportall.api.models.indicators import DayOfWeek, Indicator, Moment, Month Next, we need the [API client][pyportall.api.engine.core.APIClient] to provide the helper components with the capability to send authenticated (technically, metadata requests do not require authentication, but this behavior may change in the future anyway) requests: client = APIClient(api_key=\"MY_API_KEY\") # API key can also be automatically detected from the PYPORTALL_API_KEY enviroment variable; a batch boolean is also available (defaults to False) to avoid timeouts As a starting point for our actual analysis, let us build a DataFrame with the two addresses we want to work with: addresses = pd.DataFrame({\"street\": [\"Gran V\u00eda 46\", \"Calle Alcal\u00e1 10\"], \"city\": [\"Madrid\", \"Madrid\"]}) # addresses: # street city # 0 gran via 46 Madrid # 1 calle alcal\u00e1 10 Madrid We need to translate, i.e. geocode, those addreses into their corresponding longitude and latitude coordinates before we can actually do anything useful with them: geocoding_helper = GeocodingHelper(client) geocodings = geocoding_helper.resolve(addresses, options=GeocodingOptions(country=\"Spain\")) # geocodings: # geometry country state county city district postal_code street # 0 POINT (-3.70587 40.42048) Spain None None Madrid None None gran via 46 # 1 POINT (-3.37825 40.47281) Spain None None Madrid None None calle alcal\u00e1 10 Now we have a GeoDataFrame object with a geometry column that contains the actual coordinates that correspond to the input addresses, plus other columns with the actual input parameters. Note how we have used a [GeocodingOptions][pyportall.api.models.lbs.GeocodingOptions] object to set defaults for all the addresses. We could have added \"Madrid\" as a default option too, instead of repeating it for both addresses as we just did. We will define two different \"surroundings\" for each location: one will be the area that can be reached in less than a 200-second walk from the given point (\"isoline\"), and the other will be the visible area in all directions from that spot (i.e., considering buildings as obstacles) up to 150 meters (\"isovist\"). Let us define and compute such areas: isoline_helper = IsolineHelper(client) isolines = isoline_helper.resolve(gpd.GeoDataFrame({\"geometry\": geocodings[\"geometry\"], \"mode\": \"pedestrian\", \"range_s\": 200}, crs=\"EPSG:4326\")) # isolines: # geometry destination mode range_s moment # 0 POLYGON ((-3.70711 40.42145, -3.70668 40.42162... {'coordinates': [-3.70587, 40.42048], 'type': ... pedestrian 200 None # 1 POLYGON ((-3.37975 40.47380, -3.37967 40.47432... {'coordinates': [-3.37825, 40.47281], 'type': ... pedestrian 200 None isovist_helper = IsovistHelper(client) isovists = isovist_helper.resolve(gpd.GeoDataFrame({\"geometry\": geocodings[\"geometry\"]}, crs=\"EPSG:4326\"), options=IsovistOptions(radius_m=100)) # isovists: # geometry destination radius_m num_rays heading_deg fov_deg # 0 POLYGON ((-3.70587 40.42087, -3.70586 40.42088... {'coordinates': [-3.70587, 40.42048], 'type': ... 100 -1 0 360 # 1 POLYGON ((-3.37825 40.47294, -3.37825 40.47295... {'coordinates': [-3.37825, 40.47281], 'type': ... 100 -1 0 360 Much like with geocoding above, we could have used [IsolineOptions][pyportall.api.models.lbs.IsolineOptions] and/or [IsovistOptions][pyportall.api.models.lbs.IsovistOptions] to set default input parameters. In any case, the resulting geodataframes contain the geometry that correspond to the computed areas of interest, plus other columns with the actual input parameters. Now let us find the people count (indicator code \"pop\") we are interested in for all four areas: indicator_helper = IndicatorHelper(client) isovist_results = indicator_helper.resolve_aggregated(isovists, indicator=Indicator(code=\"pop\"), moment=Moment(dow=DayOfWeek.monday, month=Month.february, hour=15)) # isovist_results: # geometry destination fov_deg heading_deg num_rays radius_m value # 0 POLYGON ((-3.70587 40.42087, -3.70586 40.42088... {'coordinates': [-3.70587, 40.42048], 'type': ... 360 0 -1 100 969 # 1 POLYGON ((-3.37825 40.47294, -3.37825 40.47295... {'coordinates': [-3.37825, 40.47281], 'type': ... 360 0 -1 100 80 isoline_results = indicator_helper.resolve_aggregated(isolines, indicator=Indicator(code=\"pop\"), moment=Moment(dow=DayOfWeek.monday, month=Month.february, hour=10)) # isoline_results: # geometry destination mode moment range_s value # 0 POLYGON ((-3.70711 40.42145, -3.70668 40.42162... {'coordinates': [-3.70587, 40.42048], 'type': ... pedestrian None 200 42034 # 1 POLYGON ((-3.37975 40.47380, -3.37967 40.47432... {'coordinates': [-3.37825, 40.47281], 'type': ... pedestrian None 200 5784 You can see now the people count on the new value column of the dataframes. Internally, Portall splits the areas of interest in [H3 cells]/https://eng.uber.com/h3/), obtains the people count for each cell and aggregates them. It is also possible to get the disaggregated results for each of the cells. In this case, only one input geometry can be used at a time: isovist_disaggregated_results = indicator_helper.resolve_disaggregated(isovists[\"geometry\"][0], indicator=Indicator(code=\"pop\", aggregated=False), moment=Moment(dow=DayOfWeek.monday, month=Month.february, hour=15)) # isovist_disaggregated_results: # geometry id value weight # 0 POLYGON ((-3.70606 40.42066, -3.70618 40.42063... 631507574769340927 157.692308 1 # 1 POLYGON ((-3.70584 40.42064, -3.70596 40.42060... 631507574769341439 250.000000 1 # 2 POLYGON ((-3.70593 40.42080, -3.70604 40.42076... 631507574769343487 123.076923 1 # 3 POLYGON ((-3.70571 40.42077, -3.70583 40.42074... 631507574769495551 296.153846 1 # 4 POLYGON ((-3.70579 40.42094, -3.70591 40.42090... 631507574769510399 142.307692 1 isoline_disaggregated_results = indicator_helper.resolve_disaggregated(isolines[\"geometry\"][0], indicator=Indicator(code=\"pop\", aggregated=False), moment=Moment(dow=DayOfWeek.monday, month=Month.february, hour=15)) # isoline_disaggregated_results: # geometry id value weight # 0 POLYGON ((-3.70621 40.42176, -3.70633 40.42172... 631507574768870911 134.615385 1 # 1 POLYGON ((-3.70648 40.41948, -3.70660 40.41945... 631507574769392639 88.461538 1 # 2 POLYGON ((-3.70509 40.42116, -3.70521 40.42112... 631507574769484799 300.000000 1 # 3 POLYGON ((-3.70504 40.42146, -3.70515 40.42142... 631507574769506303 146.153846 1 # 4 POLYGON ((-3.70529 40.41995, -3.70541 40.41992... 631507574769377791 157.692308 1 # .. ... ... ... ... # 259 POLYGON ((-3.70557 40.41891, -3.70569 40.41887... 631507574769420287 103.846154 1 # 260 POLYGON ((-3.70574 40.41924, -3.70586 40.41920... 631507574769420799 103.846154 1 # 261 POLYGON ((-3.70541 40.42058, -3.70552 40.42054... 631507574769494015 346.153846 1 # 262 POLYGON ((-3.70589 40.42033, -3.70601 40.42030... 631507574769327615 276.923077 1 # 263 POLYGON ((-3.70531 40.41919, -3.70542 40.41915... 631507574769425919 192.307692 1 # [264 rows x 4 columns] The resulting geodataframes are different now, and represent one H3 cell per row, with its geometry and id as columns, together with the value column itself and a weight column that can be useful if you want to aggregate the data from this disaggregated geodataframe yourself. Preflight All those API requests incur in credit costs. To know about those costs in advance, you can create a preflight client and send the very same request beforehand. Preflight works for batch requests too. import pandas as pd from pyportall.api.engine.core import APIClient from pyportall.api.models.lbs import GeocodingOptions from pyportall.api.engine.geopandas import GeocodingHelper from pyportall.exceptions import PreFlightException preflight_client = APIClient(api_key=\"MY_API_KEY\", preflight=True) addresses = pd.DataFrame({\"street\": [\"Gran V\u00eda 46\", \"Calle Alcal\u00e1 10\"], \"city\": [\"Madrid\", \"Madrid\"]}) addresses preflight_geocoding_helper = GeocodingHelper(preflight_client) try: preflight_geocoding_helper.resolve(addresses, options=GeocodingOptions(country=\"Spain\")) except PreFlightException as e: geocoding_cost = e.credits # geocoding_cost: 2 (you may get a different value) Now you can simple go ahead and execute the actual operation, knowing the number of credits that will be deducted from your account: client = APIClient(api_key=\"MY_API_KEY\") geocoding_helper = GeocodingHelper(client) geocodings = geocoding_helper.resolve(addresses, options=GeocodingOptions(country=\"Spain\")) # geocodings: # geometry country state county city district postal_code street # 0 POINT (-3.70587 40.42048) Spain None None Madrid None None gran via 46 # 1 POINT (-3.37825 40.47281) Spain None None Madrid None None calle alcal\u00e1 10 Metadata You will need to look at the metadata catalog to learn about the different indicators that are available to you. Something like this: from pyportall.api.engine.core import APIClient from pyportall.api.engine.metadata import MetadataHelper client = APIClient(api_key=\"MY_API_KEY\") metadata_helper = MetadataHelper(client) footfall = metadata_helper.all()[0] # footfall: IndicatorMetadata(code='pop', name='Footfall', description='Number of people', unit='', format='', coverage='Madrid - UFA', resolution='H3 (11, 12)', data_source='Orange', computed_date=datetime.date(2019, 2, 1), aggregate_fn=<Aggregate.sum: 'sum'>, data_type=<DataType.integer: 'integer'>)","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#simple-generic-usage-example","text":"This is a very simple example that outlines how the different components work and interact with each other. The problem we will be trying to solve is understanding how many people can be counted on a Friday in February from 3pm to 4pm in the surroundings of two given locations. First of all, let us do the imports: import pandas as pd import geopandas as gpd from pyportall.api.engine.core import APIClient from pyportall.api.models.lbs import GeocodingOptions from pyportall.api.engine.geopandas import GeocodingHelper, IsolineHelper, IsovistHelper, IndicatorHelper from pyportall.api.models.indicators import DayOfWeek, Indicator, Moment, Month Next, we need the [API client][pyportall.api.engine.core.APIClient] to provide the helper components with the capability to send authenticated (technically, metadata requests do not require authentication, but this behavior may change in the future anyway) requests: client = APIClient(api_key=\"MY_API_KEY\") # API key can also be automatically detected from the PYPORTALL_API_KEY enviroment variable; a batch boolean is also available (defaults to False) to avoid timeouts As a starting point for our actual analysis, let us build a DataFrame with the two addresses we want to work with: addresses = pd.DataFrame({\"street\": [\"Gran V\u00eda 46\", \"Calle Alcal\u00e1 10\"], \"city\": [\"Madrid\", \"Madrid\"]}) # addresses: # street city # 0 gran via 46 Madrid # 1 calle alcal\u00e1 10 Madrid We need to translate, i.e. geocode, those addreses into their corresponding longitude and latitude coordinates before we can actually do anything useful with them: geocoding_helper = GeocodingHelper(client) geocodings = geocoding_helper.resolve(addresses, options=GeocodingOptions(country=\"Spain\")) # geocodings: # geometry country state county city district postal_code street # 0 POINT (-3.70587 40.42048) Spain None None Madrid None None gran via 46 # 1 POINT (-3.37825 40.47281) Spain None None Madrid None None calle alcal\u00e1 10 Now we have a GeoDataFrame object with a geometry column that contains the actual coordinates that correspond to the input addresses, plus other columns with the actual input parameters. Note how we have used a [GeocodingOptions][pyportall.api.models.lbs.GeocodingOptions] object to set defaults for all the addresses. We could have added \"Madrid\" as a default option too, instead of repeating it for both addresses as we just did. We will define two different \"surroundings\" for each location: one will be the area that can be reached in less than a 200-second walk from the given point (\"isoline\"), and the other will be the visible area in all directions from that spot (i.e., considering buildings as obstacles) up to 150 meters (\"isovist\"). Let us define and compute such areas: isoline_helper = IsolineHelper(client) isolines = isoline_helper.resolve(gpd.GeoDataFrame({\"geometry\": geocodings[\"geometry\"], \"mode\": \"pedestrian\", \"range_s\": 200}, crs=\"EPSG:4326\")) # isolines: # geometry destination mode range_s moment # 0 POLYGON ((-3.70711 40.42145, -3.70668 40.42162... {'coordinates': [-3.70587, 40.42048], 'type': ... pedestrian 200 None # 1 POLYGON ((-3.37975 40.47380, -3.37967 40.47432... {'coordinates': [-3.37825, 40.47281], 'type': ... pedestrian 200 None isovist_helper = IsovistHelper(client) isovists = isovist_helper.resolve(gpd.GeoDataFrame({\"geometry\": geocodings[\"geometry\"]}, crs=\"EPSG:4326\"), options=IsovistOptions(radius_m=100)) # isovists: # geometry destination radius_m num_rays heading_deg fov_deg # 0 POLYGON ((-3.70587 40.42087, -3.70586 40.42088... {'coordinates': [-3.70587, 40.42048], 'type': ... 100 -1 0 360 # 1 POLYGON ((-3.37825 40.47294, -3.37825 40.47295... {'coordinates': [-3.37825, 40.47281], 'type': ... 100 -1 0 360 Much like with geocoding above, we could have used [IsolineOptions][pyportall.api.models.lbs.IsolineOptions] and/or [IsovistOptions][pyportall.api.models.lbs.IsovistOptions] to set default input parameters. In any case, the resulting geodataframes contain the geometry that correspond to the computed areas of interest, plus other columns with the actual input parameters. Now let us find the people count (indicator code \"pop\") we are interested in for all four areas: indicator_helper = IndicatorHelper(client) isovist_results = indicator_helper.resolve_aggregated(isovists, indicator=Indicator(code=\"pop\"), moment=Moment(dow=DayOfWeek.monday, month=Month.february, hour=15)) # isovist_results: # geometry destination fov_deg heading_deg num_rays radius_m value # 0 POLYGON ((-3.70587 40.42087, -3.70586 40.42088... {'coordinates': [-3.70587, 40.42048], 'type': ... 360 0 -1 100 969 # 1 POLYGON ((-3.37825 40.47294, -3.37825 40.47295... {'coordinates': [-3.37825, 40.47281], 'type': ... 360 0 -1 100 80 isoline_results = indicator_helper.resolve_aggregated(isolines, indicator=Indicator(code=\"pop\"), moment=Moment(dow=DayOfWeek.monday, month=Month.february, hour=10)) # isoline_results: # geometry destination mode moment range_s value # 0 POLYGON ((-3.70711 40.42145, -3.70668 40.42162... {'coordinates': [-3.70587, 40.42048], 'type': ... pedestrian None 200 42034 # 1 POLYGON ((-3.37975 40.47380, -3.37967 40.47432... {'coordinates': [-3.37825, 40.47281], 'type': ... pedestrian None 200 5784 You can see now the people count on the new value column of the dataframes. Internally, Portall splits the areas of interest in [H3 cells]/https://eng.uber.com/h3/), obtains the people count for each cell and aggregates them. It is also possible to get the disaggregated results for each of the cells. In this case, only one input geometry can be used at a time: isovist_disaggregated_results = indicator_helper.resolve_disaggregated(isovists[\"geometry\"][0], indicator=Indicator(code=\"pop\", aggregated=False), moment=Moment(dow=DayOfWeek.monday, month=Month.february, hour=15)) # isovist_disaggregated_results: # geometry id value weight # 0 POLYGON ((-3.70606 40.42066, -3.70618 40.42063... 631507574769340927 157.692308 1 # 1 POLYGON ((-3.70584 40.42064, -3.70596 40.42060... 631507574769341439 250.000000 1 # 2 POLYGON ((-3.70593 40.42080, -3.70604 40.42076... 631507574769343487 123.076923 1 # 3 POLYGON ((-3.70571 40.42077, -3.70583 40.42074... 631507574769495551 296.153846 1 # 4 POLYGON ((-3.70579 40.42094, -3.70591 40.42090... 631507574769510399 142.307692 1 isoline_disaggregated_results = indicator_helper.resolve_disaggregated(isolines[\"geometry\"][0], indicator=Indicator(code=\"pop\", aggregated=False), moment=Moment(dow=DayOfWeek.monday, month=Month.february, hour=15)) # isoline_disaggregated_results: # geometry id value weight # 0 POLYGON ((-3.70621 40.42176, -3.70633 40.42172... 631507574768870911 134.615385 1 # 1 POLYGON ((-3.70648 40.41948, -3.70660 40.41945... 631507574769392639 88.461538 1 # 2 POLYGON ((-3.70509 40.42116, -3.70521 40.42112... 631507574769484799 300.000000 1 # 3 POLYGON ((-3.70504 40.42146, -3.70515 40.42142... 631507574769506303 146.153846 1 # 4 POLYGON ((-3.70529 40.41995, -3.70541 40.41992... 631507574769377791 157.692308 1 # .. ... ... ... ... # 259 POLYGON ((-3.70557 40.41891, -3.70569 40.41887... 631507574769420287 103.846154 1 # 260 POLYGON ((-3.70574 40.41924, -3.70586 40.41920... 631507574769420799 103.846154 1 # 261 POLYGON ((-3.70541 40.42058, -3.70552 40.42054... 631507574769494015 346.153846 1 # 262 POLYGON ((-3.70589 40.42033, -3.70601 40.42030... 631507574769327615 276.923077 1 # 263 POLYGON ((-3.70531 40.41919, -3.70542 40.41915... 631507574769425919 192.307692 1 # [264 rows x 4 columns] The resulting geodataframes are different now, and represent one H3 cell per row, with its geometry and id as columns, together with the value column itself and a weight column that can be useful if you want to aggregate the data from this disaggregated geodataframe yourself.","title":"Simple, generic usage example"},{"location":"examples/#preflight","text":"All those API requests incur in credit costs. To know about those costs in advance, you can create a preflight client and send the very same request beforehand. Preflight works for batch requests too. import pandas as pd from pyportall.api.engine.core import APIClient from pyportall.api.models.lbs import GeocodingOptions from pyportall.api.engine.geopandas import GeocodingHelper from pyportall.exceptions import PreFlightException preflight_client = APIClient(api_key=\"MY_API_KEY\", preflight=True) addresses = pd.DataFrame({\"street\": [\"Gran V\u00eda 46\", \"Calle Alcal\u00e1 10\"], \"city\": [\"Madrid\", \"Madrid\"]}) addresses preflight_geocoding_helper = GeocodingHelper(preflight_client) try: preflight_geocoding_helper.resolve(addresses, options=GeocodingOptions(country=\"Spain\")) except PreFlightException as e: geocoding_cost = e.credits # geocoding_cost: 2 (you may get a different value) Now you can simple go ahead and execute the actual operation, knowing the number of credits that will be deducted from your account: client = APIClient(api_key=\"MY_API_KEY\") geocoding_helper = GeocodingHelper(client) geocodings = geocoding_helper.resolve(addresses, options=GeocodingOptions(country=\"Spain\")) # geocodings: # geometry country state county city district postal_code street # 0 POINT (-3.70587 40.42048) Spain None None Madrid None None gran via 46 # 1 POINT (-3.37825 40.47281) Spain None None Madrid None None calle alcal\u00e1 10","title":"Preflight"},{"location":"examples/#metadata","text":"You will need to look at the metadata catalog to learn about the different indicators that are available to you. Something like this: from pyportall.api.engine.core import APIClient from pyportall.api.engine.metadata import MetadataHelper client = APIClient(api_key=\"MY_API_KEY\") metadata_helper = MetadataHelper(client) footfall = metadata_helper.all()[0] # footfall: IndicatorMetadata(code='pop', name='Footfall', description='Number of people', unit='', format='', coverage='Madrid - UFA', resolution='H3 (11, 12)', data_source='Orange', computed_date=datetime.date(2019, 2, 1), aggregate_fn=<Aggregate.sum: 'sum'>, data_type=<DataType.integer: 'integer'>)","title":"Metadata"},{"location":"getting_started/","text":"Getting started Installation Installing is straightforward: $ pip install pyportall Or, as part of your requirements.txt file: ... pyportall ... Currently, GeoPandas is required for this SDK to work. We may release a standalone SDK version in the future. Tests You may want to verify the installation is correct by running the test suite. Just run pytest if you want to run the tests against a mocked API: $ pytest You can also run the test suite against the live API if you use a real API key: $ env PYPORTALL_API_KEY=MY_API_KEY pytest Authentication Your can use the API_KEY environment variable to store your API key to Portall for the Python SDK to work, or pass it to [APIClient][pyportall.api.engine.core.APIClient] when instantiating the API client, as described in the next section. Restrictions You may get 429 \"too many requests\" error if you run above the maximum number of requests per second set by your plan. On a similar fashion, API calls cost credits. If you run out of credits, you will start receiving 429 error messages too.","title":"Getting started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#installation","text":"Installing is straightforward: $ pip install pyportall Or, as part of your requirements.txt file: ... pyportall ... Currently, GeoPandas is required for this SDK to work. We may release a standalone SDK version in the future.","title":"Installation"},{"location":"getting_started/#tests","text":"You may want to verify the installation is correct by running the test suite. Just run pytest if you want to run the tests against a mocked API: $ pytest You can also run the test suite against the live API if you use a real API key: $ env PYPORTALL_API_KEY=MY_API_KEY pytest","title":"Tests"},{"location":"getting_started/#authentication","text":"Your can use the API_KEY environment variable to store your API key to Portall for the Python SDK to work, or pass it to [APIClient][pyportall.api.engine.core.APIClient] when instantiating the API client, as described in the next section.","title":"Authentication"},{"location":"getting_started/#restrictions","text":"You may get 429 \"too many requests\" error if you run above the maximum number of requests per second set by your plan. On a similar fashion, API calls cost credits. If you run out of credits, you will start receiving 429 error messages too.","title":"Restrictions"},{"location":"ref_engine/","text":"core Module where core API-related classes live. APIClient This class holds the direct interface to Portall's API. Other classes may need to use one API client to actually send requests to the API. __init__ ( self , api_key = None , batch = False , preflight = False ) special When instantiating an API client, you will provide an API key and optionally opt for batch or preflight modes. In preflight mode, requests to the API will not be executed. Instead, the API returns the estimated cost in credits for such request. Use batch mode when requests take longer to execute than the default API timeout (around 15s). Parameters: Name Type Description Default api_key Optional[str] API key to use with Portall's API, in case no API key is available via the PYPORTALL_API_KEY environment variable. Please contact us if you need one. None batch Optional[bool] Whether the client will work in batch mode or not. False preflight Optional[bool] Whether the client will work in preflight mode or not. False Exceptions: Type Description PyPortallException Raised if no API key is available either through the api_key parameter or the PYPORTALL_API_KEY environment variable. call_indicators ( self , url , input ) Send requests to Portall's indicator API. Takes an arbitrary object and, as long as it can be transformed into a JSON string, sends it to the indicator API. It deals with preflight and batch mode according to the settings defined upon creation of the client. Parameters: Name Type Description Default url str URL of the specific API endpoint in question. required input Any Any python object that can be encoded to a JSON string. required Returns: Type Description Any The Python object derived from the JSON received by the API. Exceptions: Type Description AuthError Authentication has failed, probably because of a wrong API key. BatchError A batch request has failed, because of an error or because the batch timeout has expired. PreFlightException Raised in preflight mode, includes the number of estimated credits that the actual request would consume. PyPortallException Generic API exception. RateLimitError The request cannot be fulfilled because either the company credit has run out or the maximum number of allowed requests per second has been exceeded. TimeoutError A regular (non-batch) request has timed out. ValidationError The format of the request is not valid. call_metadata ( self ) Send requests to Portall's metadata API. Returns: Type Description Any The Python object derived from the JSON received by the API. Exceptions: Type Description PyPortallException Generic API exception. APIHelper Ensure a common structure for helpers that actually do things. __init__ ( self , client ) special Class constructor to attach the coresponding API client. Parameters: Name Type Description Default client APIClient API client object that the helper will use to actually send requests to the API when it has to. required geopandas Module where the (Geo)Pandas helpers live. GeocodingHelper Help with street addresses. resolve ( self , df , options = None ) Find latitude and longitude for a number of street addresses. Turn a DataFrame with street addresses into a GeoDataFrame where the geometry column derives from the corresponding latitude and longitude, once those addresses have been properly geocoded. Parameters: Name Type Description Default df DataFrame DataFrame with at least one street column that includes full or partial addresses to be geocoded. Even though street is the only mandatory column and can contain arbitrary, partial or full addreses, geocoding typically works better if the full address is split into several fields. Therefore, other columns can help improve the accuracy of the geocoding process, namely country , county , city , district and postal_code . required options Optional[pyportall.api.models.lbs.GeocodingOptions] Default values for the country , county , city , district and postal_code columns of the DataFrame, when they are not present. None Returns: Type Description GeoDataFrame A GeoDataFrame with all the geocoding columns plus the geometry column with the actual points derived from the geocoding process. IndicatorHelper Help with indicators. resolve_aggregated ( self , gdf , indicator = None , moment = None ) Find the value of an aggregated indicator for a number of target geometries in a particular moment in time. Given a moment in time, a number of geometries and a target indicator, find the aggregated indicator value for each of the geometries in the specified moment. Parameters: Name Type Description Default gdf GeoDataFrame GeoDataFrame with a geometry column that stands for the geometries to be used on the calculations. required indicator Optional[pyportall.api.models.indicators.Indicator] The indicator to be computed. None moment Optional[pyportall.api.models.indicators.Moment] The moment in time that will be used for the calculations. None Returns: Type Description GeoDataFrame A copy of the original GeoDataFrame with a new column value with the computed values for each geometry. resolve_disaggregated ( self , polygon , indicator , moment ) Find the disaggregated values for an indicator over a target geometry in a particular moment in time. Given a moment in time, one geometry and a target indicator, find the H3 cells underneath the given geometry and compute the indicator value for each of them. Parameters: Name Type Description Default polygon Polygon Geometry to be used on the calculations. required indicator Indicator The indicator to be computed. required moment Moment The moment in time that will be used for the calculations. required Returns: Type Description GeoDataFrame A GeoDataFrame with one row per H3 cells and columns: id with the H3 cell id, geometry with the geometry of the H3 cells, value with the indicator value for the cell, and weight , which is useful if you want to aggregate the data from this disaggregated geodataframe yourself. IsolineHelper Help with isovists. resolve ( self , gdf , options = None ) Find isolines (space that can be reached in a certain amount of time from a given point in space). Turn a GeoDataFrame with points and other parameters the define isolines into another GeoDataFrame where the geometry column is formed by the polygons that translate to such isoline definitions. Parameters: Name Type Description Default gdf GeoDataFrame GeoDataFrame with a geometry column with the target points and other columns to help define the isolines, Such columns are mode , range , and moment . required options Optional[pyportall.api.models.lbs.IsolineOptions] Default values for the mode , range , and moment columns of the original GeoDataFrame , when they are not present. None Returns: Type Description GeoDataFrame A GeoDataFrame with all the isoline definition columns plus a destination column with the original points. The geometry column now holds the actual polygons derived from computing the isolines. IsovistHelper Help with isolines. resolve ( self , gdf , options = None ) Find isovists (space visible from a given point in space). Turn a GeoDataFrame with points and other parameters the define isovists into another GeoDataFrame where the geometry column is formed by the polygons that translate to such isovist definitions. Parameters: Name Type Description Default gdf GeoDataFrame GeoDataFrame with a geometry column with the target points and other columns to help define the isovists, Such columns are radius_m , num_rays , heading_deg and fov_deg . required options Optional[pyportall.api.models.lbs.IsovistOptions] Default values for the radius_m , num_rays , heading_deg and fov_deg columns of the original GeoDataFrame, when they are not present. None Returns: Type Description GeoDataFrame A GeoDataFrame with all the isovist definition columns plus a destination column with the original points. The geometry column now holds the actual polygons derived from computing the isovists. metadata Module where the metadata helpers live. MetadataHelper Help with indicator metadata. __init__ ( self , client ) special Class constructor to attach the coresponding API client. Parameters: Name Type Description Default client APIClient API client object that the helper will use to actually send requests to the metadata API when it has to. required all ( self ) Get all the indicators available in the metadata database. Returns: Type Description List[pyportall.api.models.metadata.IndicatorMetadata] A list of indicators with their metadata. get ( self , indicator_code ) Get just one of the indicators available in the metadata database. Parameters: Name Type Description Default indicator_code str Code of the indicator to be retrieved. required Returns: Type Description Optional[pyportall.api.models.metadata.IndicatorMetadata] Indicator with its metadata. refresh ( self ) Update the metadata with a fresh copy from the database.","title":"pyportall.api.engine"},{"location":"ref_engine/#pyportall.api.engine","text":"","title":"pyportall.api.engine"},{"location":"ref_engine/#pyportall.api.engine.core","text":"Module where core API-related classes live.","title":"core"},{"location":"ref_engine/#pyportall.api.engine.core.APIClient","text":"This class holds the direct interface to Portall's API. Other classes may need to use one API client to actually send requests to the API.","title":"APIClient"},{"location":"ref_engine/#pyportall.api.engine.core.APIClient.__init__","text":"When instantiating an API client, you will provide an API key and optionally opt for batch or preflight modes. In preflight mode, requests to the API will not be executed. Instead, the API returns the estimated cost in credits for such request. Use batch mode when requests take longer to execute than the default API timeout (around 15s). Parameters: Name Type Description Default api_key Optional[str] API key to use with Portall's API, in case no API key is available via the PYPORTALL_API_KEY environment variable. Please contact us if you need one. None batch Optional[bool] Whether the client will work in batch mode or not. False preflight Optional[bool] Whether the client will work in preflight mode or not. False Exceptions: Type Description PyPortallException Raised if no API key is available either through the api_key parameter or the PYPORTALL_API_KEY environment variable.","title":"__init__()"},{"location":"ref_engine/#pyportall.api.engine.core.APIClient.call_indicators","text":"Send requests to Portall's indicator API. Takes an arbitrary object and, as long as it can be transformed into a JSON string, sends it to the indicator API. It deals with preflight and batch mode according to the settings defined upon creation of the client. Parameters: Name Type Description Default url str URL of the specific API endpoint in question. required input Any Any python object that can be encoded to a JSON string. required Returns: Type Description Any The Python object derived from the JSON received by the API. Exceptions: Type Description AuthError Authentication has failed, probably because of a wrong API key. BatchError A batch request has failed, because of an error or because the batch timeout has expired. PreFlightException Raised in preflight mode, includes the number of estimated credits that the actual request would consume. PyPortallException Generic API exception. RateLimitError The request cannot be fulfilled because either the company credit has run out or the maximum number of allowed requests per second has been exceeded. TimeoutError A regular (non-batch) request has timed out. ValidationError The format of the request is not valid.","title":"call_indicators()"},{"location":"ref_engine/#pyportall.api.engine.core.APIClient.call_metadata","text":"Send requests to Portall's metadata API. Returns: Type Description Any The Python object derived from the JSON received by the API. Exceptions: Type Description PyPortallException Generic API exception.","title":"call_metadata()"},{"location":"ref_engine/#pyportall.api.engine.core.APIHelper","text":"Ensure a common structure for helpers that actually do things.","title":"APIHelper"},{"location":"ref_engine/#pyportall.api.engine.core.APIHelper.__init__","text":"Class constructor to attach the coresponding API client. Parameters: Name Type Description Default client APIClient API client object that the helper will use to actually send requests to the API when it has to. required","title":"__init__()"},{"location":"ref_engine/#pyportall.api.engine.geopandas","text":"Module where the (Geo)Pandas helpers live.","title":"geopandas"},{"location":"ref_engine/#pyportall.api.engine.geopandas.GeocodingHelper","text":"Help with street addresses.","title":"GeocodingHelper"},{"location":"ref_engine/#pyportall.api.engine.geopandas.GeocodingHelper.resolve","text":"Find latitude and longitude for a number of street addresses. Turn a DataFrame with street addresses into a GeoDataFrame where the geometry column derives from the corresponding latitude and longitude, once those addresses have been properly geocoded. Parameters: Name Type Description Default df DataFrame DataFrame with at least one street column that includes full or partial addresses to be geocoded. Even though street is the only mandatory column and can contain arbitrary, partial or full addreses, geocoding typically works better if the full address is split into several fields. Therefore, other columns can help improve the accuracy of the geocoding process, namely country , county , city , district and postal_code . required options Optional[pyportall.api.models.lbs.GeocodingOptions] Default values for the country , county , city , district and postal_code columns of the DataFrame, when they are not present. None Returns: Type Description GeoDataFrame A GeoDataFrame with all the geocoding columns plus the geometry column with the actual points derived from the geocoding process.","title":"resolve()"},{"location":"ref_engine/#pyportall.api.engine.geopandas.IndicatorHelper","text":"Help with indicators.","title":"IndicatorHelper"},{"location":"ref_engine/#pyportall.api.engine.geopandas.IndicatorHelper.resolve_aggregated","text":"Find the value of an aggregated indicator for a number of target geometries in a particular moment in time. Given a moment in time, a number of geometries and a target indicator, find the aggregated indicator value for each of the geometries in the specified moment. Parameters: Name Type Description Default gdf GeoDataFrame GeoDataFrame with a geometry column that stands for the geometries to be used on the calculations. required indicator Optional[pyportall.api.models.indicators.Indicator] The indicator to be computed. None moment Optional[pyportall.api.models.indicators.Moment] The moment in time that will be used for the calculations. None Returns: Type Description GeoDataFrame A copy of the original GeoDataFrame with a new column value with the computed values for each geometry.","title":"resolve_aggregated()"},{"location":"ref_engine/#pyportall.api.engine.geopandas.IndicatorHelper.resolve_disaggregated","text":"Find the disaggregated values for an indicator over a target geometry in a particular moment in time. Given a moment in time, one geometry and a target indicator, find the H3 cells underneath the given geometry and compute the indicator value for each of them. Parameters: Name Type Description Default polygon Polygon Geometry to be used on the calculations. required indicator Indicator The indicator to be computed. required moment Moment The moment in time that will be used for the calculations. required Returns: Type Description GeoDataFrame A GeoDataFrame with one row per H3 cells and columns: id with the H3 cell id, geometry with the geometry of the H3 cells, value with the indicator value for the cell, and weight , which is useful if you want to aggregate the data from this disaggregated geodataframe yourself.","title":"resolve_disaggregated()"},{"location":"ref_engine/#pyportall.api.engine.geopandas.IsolineHelper","text":"Help with isovists.","title":"IsolineHelper"},{"location":"ref_engine/#pyportall.api.engine.geopandas.IsolineHelper.resolve","text":"Find isolines (space that can be reached in a certain amount of time from a given point in space). Turn a GeoDataFrame with points and other parameters the define isolines into another GeoDataFrame where the geometry column is formed by the polygons that translate to such isoline definitions. Parameters: Name Type Description Default gdf GeoDataFrame GeoDataFrame with a geometry column with the target points and other columns to help define the isolines, Such columns are mode , range , and moment . required options Optional[pyportall.api.models.lbs.IsolineOptions] Default values for the mode , range , and moment columns of the original GeoDataFrame , when they are not present. None Returns: Type Description GeoDataFrame A GeoDataFrame with all the isoline definition columns plus a destination column with the original points. The geometry column now holds the actual polygons derived from computing the isolines.","title":"resolve()"},{"location":"ref_engine/#pyportall.api.engine.geopandas.IsovistHelper","text":"Help with isolines.","title":"IsovistHelper"},{"location":"ref_engine/#pyportall.api.engine.geopandas.IsovistHelper.resolve","text":"Find isovists (space visible from a given point in space). Turn a GeoDataFrame with points and other parameters the define isovists into another GeoDataFrame where the geometry column is formed by the polygons that translate to such isovist definitions. Parameters: Name Type Description Default gdf GeoDataFrame GeoDataFrame with a geometry column with the target points and other columns to help define the isovists, Such columns are radius_m , num_rays , heading_deg and fov_deg . required options Optional[pyportall.api.models.lbs.IsovistOptions] Default values for the radius_m , num_rays , heading_deg and fov_deg columns of the original GeoDataFrame, when they are not present. None Returns: Type Description GeoDataFrame A GeoDataFrame with all the isovist definition columns plus a destination column with the original points. The geometry column now holds the actual polygons derived from computing the isovists.","title":"resolve()"},{"location":"ref_engine/#pyportall.api.engine.metadata","text":"Module where the metadata helpers live.","title":"metadata"},{"location":"ref_engine/#pyportall.api.engine.metadata.MetadataHelper","text":"Help with indicator metadata.","title":"MetadataHelper"},{"location":"ref_engine/#pyportall.api.engine.metadata.MetadataHelper.__init__","text":"Class constructor to attach the coresponding API client. Parameters: Name Type Description Default client APIClient API client object that the helper will use to actually send requests to the metadata API when it has to. required","title":"__init__()"},{"location":"ref_engine/#pyportall.api.engine.metadata.MetadataHelper.all","text":"Get all the indicators available in the metadata database. Returns: Type Description List[pyportall.api.models.metadata.IndicatorMetadata] A list of indicators with their metadata.","title":"all()"},{"location":"ref_engine/#pyportall.api.engine.metadata.MetadataHelper.get","text":"Get just one of the indicators available in the metadata database. Parameters: Name Type Description Default indicator_code str Code of the indicator to be retrieved. required Returns: Type Description Optional[pyportall.api.models.metadata.IndicatorMetadata] Indicator with its metadata.","title":"get()"},{"location":"ref_engine/#pyportall.api.engine.metadata.MetadataHelper.refresh","text":"Update the metadata with a fresh copy from the database.","title":"refresh()"},{"location":"ref_exceptions/","text":"PyPortall custom exceptions. AuthError Authentication has failed, probably because of a wrong API key. BatchError A batch request has failed, because of an error or because the batch timeout has expired. PreFlightException Raised in preflight mode, includes the number of estimated credits that the actual request would consume. __init__ ( self , credits , * args ) special Constructor. Parameters: Name Type Description Default credits Number of credits the request will cost. required PyPortallException Generic API exception. RateLimitError The request cannot be fulfilled because either the company credit has run out or the maximum number of allowed requests per second has been exceeded. TimeoutError A regular (non-batch) request has timed out. ValidationError API is complaining the format of the request is not valid.","title":"pyportall.exceptions"},{"location":"ref_exceptions/#pyportall.exceptions","text":"PyPortall custom exceptions.","title":"pyportall.exceptions"},{"location":"ref_exceptions/#pyportall.exceptions.AuthError","text":"Authentication has failed, probably because of a wrong API key.","title":"AuthError"},{"location":"ref_exceptions/#pyportall.exceptions.BatchError","text":"A batch request has failed, because of an error or because the batch timeout has expired.","title":"BatchError"},{"location":"ref_exceptions/#pyportall.exceptions.PreFlightException","text":"Raised in preflight mode, includes the number of estimated credits that the actual request would consume.","title":"PreFlightException"},{"location":"ref_exceptions/#pyportall.exceptions.PreFlightException.__init__","text":"Constructor. Parameters: Name Type Description Default credits Number of credits the request will cost. required","title":"__init__()"},{"location":"ref_exceptions/#pyportall.exceptions.PyPortallException","text":"Generic API exception.","title":"PyPortallException"},{"location":"ref_exceptions/#pyportall.exceptions.RateLimitError","text":"The request cannot be fulfilled because either the company credit has run out or the maximum number of allowed requests per second has been exceeded.","title":"RateLimitError"},{"location":"ref_exceptions/#pyportall.exceptions.TimeoutError","text":"A regular (non-batch) request has timed out.","title":"TimeoutError"},{"location":"ref_exceptions/#pyportall.exceptions.ValidationError","text":"API is complaining the format of the request is not valid.","title":"ValidationError"},{"location":"ref_models/","text":"indicators Indicator-related model classes. DayOfWeek Day of the week. Indicator pydantic-model Defines a measurement to be computed, typically after a location and a moment have been defined. aggregated: bool pydantic-field True means a single value is returned for the entire geometry; false means original cells and values are preserved. code: str pydantic-field required Indicator code as defined in the metadata database. normalization: Normalization pydantic-field Requested geospatial normalization. percent: bool pydantic-field Whether the value is required to be a percentage. Moment pydantic-model Combination of hour, day of the week, month and year to be used when computing an indicator or requesting an isoline. dow: DayOfWeek pydantic-field required Day of the week. Month Month. Normalization Geospatial normalization, where total means the actual value for a given area and density means values are normalized by area. lbs Models that relate to location-based services. GeocodingOptions pydantic-model Options to be used as fallback when the specific addresses do not have their own. city: str pydantic-field City or municipality. country: str pydantic-field Country in English. county: str pydantic-field County or province. district: str pydantic-field District or neighborhood. postal_code: str pydantic-field Postal code. state: str pydantic-field State or region. IsolineMode Transportation mode to use when computing an isoline. IsolineOptions pydantic-model Options to be used as fallback when the specific isolines do not have their own. mode: IsolineMode pydantic-field Means of transport used to calculate the isoline border. moment: Moment pydantic-field Moment in time to use when estimating the isoline border. range_s: int pydantic-field Number of seconds to be taken into account to calculate the isoline border. IsovistOptions pydantic-model Options to be used as fallback when the specific isovists do not have their own. fov_deg: int pydantic-field Field of view in degrees, centered in the heading direction. heading_deg: int pydantic-field Northing in degrees, to set the direction the eyeballs are looking at. num_rays: int pydantic-field Number of angular steps that will define the resolution (-1 means 1 ray per field of view degree). radius_m: int pydantic-field Maximum number of meters to be taken into account to calculate the isovist border. metadata Indicator metadata-related model classes. Aggregate An enumeration. DataType An enumeration. Format An enumeration. preflight Preflight requests related model classes. Preflight pydantic-model Credit information for a given request. detail: int pydantic-field required Cost in credits of a given request.","title":"pyportall.api.models"},{"location":"ref_models/#pyportall.api.models","text":"","title":"pyportall.api.models"},{"location":"ref_models/#pyportall.api.models.indicators","text":"Indicator-related model classes.","title":"indicators"},{"location":"ref_models/#pyportall.api.models.indicators.DayOfWeek","text":"Day of the week.","title":"DayOfWeek"},{"location":"ref_models/#pyportall.api.models.indicators.Indicator","text":"Defines a measurement to be computed, typically after a location and a moment have been defined.","title":"Indicator"},{"location":"ref_models/#pyportall.api.models.indicators.Indicator.aggregated","text":"True means a single value is returned for the entire geometry; false means original cells and values are preserved.","title":"aggregated"},{"location":"ref_models/#pyportall.api.models.indicators.Indicator.code","text":"Indicator code as defined in the metadata database.","title":"code"},{"location":"ref_models/#pyportall.api.models.indicators.Indicator.normalization","text":"Requested geospatial normalization.","title":"normalization"},{"location":"ref_models/#pyportall.api.models.indicators.Indicator.percent","text":"Whether the value is required to be a percentage.","title":"percent"},{"location":"ref_models/#pyportall.api.models.indicators.Moment","text":"Combination of hour, day of the week, month and year to be used when computing an indicator or requesting an isoline.","title":"Moment"},{"location":"ref_models/#pyportall.api.models.indicators.Moment.dow","text":"Day of the week.","title":"dow"},{"location":"ref_models/#pyportall.api.models.indicators.Month","text":"Month.","title":"Month"},{"location":"ref_models/#pyportall.api.models.indicators.Normalization","text":"Geospatial normalization, where total means the actual value for a given area and density means values are normalized by area.","title":"Normalization"},{"location":"ref_models/#pyportall.api.models.lbs","text":"Models that relate to location-based services.","title":"lbs"},{"location":"ref_models/#pyportall.api.models.lbs.GeocodingOptions","text":"Options to be used as fallback when the specific addresses do not have their own.","title":"GeocodingOptions"},{"location":"ref_models/#pyportall.api.models.lbs.GeocodingOptions.city","text":"City or municipality.","title":"city"},{"location":"ref_models/#pyportall.api.models.lbs.GeocodingOptions.country","text":"Country in English.","title":"country"},{"location":"ref_models/#pyportall.api.models.lbs.GeocodingOptions.county","text":"County or province.","title":"county"},{"location":"ref_models/#pyportall.api.models.lbs.GeocodingOptions.district","text":"District or neighborhood.","title":"district"},{"location":"ref_models/#pyportall.api.models.lbs.GeocodingOptions.postal_code","text":"Postal code.","title":"postal_code"},{"location":"ref_models/#pyportall.api.models.lbs.GeocodingOptions.state","text":"State or region.","title":"state"},{"location":"ref_models/#pyportall.api.models.lbs.IsolineMode","text":"Transportation mode to use when computing an isoline.","title":"IsolineMode"},{"location":"ref_models/#pyportall.api.models.lbs.IsolineOptions","text":"Options to be used as fallback when the specific isolines do not have their own.","title":"IsolineOptions"},{"location":"ref_models/#pyportall.api.models.lbs.IsolineOptions.mode","text":"Means of transport used to calculate the isoline border.","title":"mode"},{"location":"ref_models/#pyportall.api.models.lbs.IsolineOptions.moment","text":"Moment in time to use when estimating the isoline border.","title":"moment"},{"location":"ref_models/#pyportall.api.models.lbs.IsolineOptions.range_s","text":"Number of seconds to be taken into account to calculate the isoline border.","title":"range_s"},{"location":"ref_models/#pyportall.api.models.lbs.IsovistOptions","text":"Options to be used as fallback when the specific isovists do not have their own.","title":"IsovistOptions"},{"location":"ref_models/#pyportall.api.models.lbs.IsovistOptions.fov_deg","text":"Field of view in degrees, centered in the heading direction.","title":"fov_deg"},{"location":"ref_models/#pyportall.api.models.lbs.IsovistOptions.heading_deg","text":"Northing in degrees, to set the direction the eyeballs are looking at.","title":"heading_deg"},{"location":"ref_models/#pyportall.api.models.lbs.IsovistOptions.num_rays","text":"Number of angular steps that will define the resolution (-1 means 1 ray per field of view degree).","title":"num_rays"},{"location":"ref_models/#pyportall.api.models.lbs.IsovistOptions.radius_m","text":"Maximum number of meters to be taken into account to calculate the isovist border.","title":"radius_m"},{"location":"ref_models/#pyportall.api.models.metadata","text":"Indicator metadata-related model classes.","title":"metadata"},{"location":"ref_models/#pyportall.api.models.metadata.Aggregate","text":"An enumeration.","title":"Aggregate"},{"location":"ref_models/#pyportall.api.models.metadata.DataType","text":"An enumeration.","title":"DataType"},{"location":"ref_models/#pyportall.api.models.metadata.Format","text":"An enumeration.","title":"Format"},{"location":"ref_models/#pyportall.api.models.preflight","text":"Preflight requests related model classes.","title":"preflight"},{"location":"ref_models/#pyportall.api.models.preflight.Preflight","text":"Credit information for a given request.","title":"Preflight"},{"location":"ref_models/#pyportall.api.models.preflight.Preflight.detail","text":"Cost in credits of a given request.","title":"detail"}]}